# -*- coding: utf-8 -*-
"""pdf_processor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18NwYvrWENMInJcjClnvKh4yFjvBJo_F3
"""

!pip install PyPDF2

import os
import sys
import json
import re
import PyPDF2
from typing import Optional

# try:
#     import PyPDF2
# except ImportError:
#     print("Error: PyPDF2 library is not installed. Please install it using 'pip install PyPDF2'")
#     sys.exit(1)

class PDFProcessor:
    def __init__(self, config_path: Optional[str] = None):
        self.base_folder = "/content"
        self.pdf_path = os.path.join(self.base_folder, "Chemistry Questions.pdf")
        self.output_path = os.path.join(self.base_folder, "output.txt")
        self.config = self.load_config(config_path)

    def load_config(self, config_path: Optional[str] = None) -> dict:
        """Load configuration file with error handling."""
        default_config = {"regex": None}

        if not config_path:
            print("Warning: No configuration file provided. Using default configuration.")
            return default_config

        try:
            with open(config_path, 'r') as config_file:
                config = json.load(config_file)

            if not config.get('regex'):
                print("Warning: No regex pattern found in configuration. Using default.")
                return default_config

            return config
        except FileNotFoundError:
            print(f"Error: Configuration file {config_path} not found.")
            return default_config
        except json.JSONDecodeError:
            print(f"Error: Invalid JSON in configuration file {config_path}.")
            return default_config

    def validate_inputs(self, page_number: Optional[str], chapter_name: Optional[str]) -> bool:
        """Validate command line inputs."""
        # if not page_number or not page_number.strip():
        if not page_number:
          print("Error: Empty page number provided.")
          return False

        if not chapter_name or not chapter_name.strip():
            print("Error: Empty chapter name provided.")
            return False

        return True

    def read_pdf_page(self, page_number: int) -> Optional[str]:
        """Read a specific page from the PDF."""
        try:
            with open(self.pdf_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)

                if page_number < 1 or page_number > len(pdf_reader.pages):
                    print(f"Error: Invalid page number. PDF has {len(pdf_reader.pages)} pages.")
                    return None

                page = pdf_reader.pages[page_number - 1]
                content = page.extract_text()

                # Apply regex filtering if configured
                if self.config.get('regex'):
                    matches = re.findall(self.config['regex'], content, re.MULTILINE)
                    content = '\n'.join(matches) if matches else content

                return content

        except FileNotFoundError:
            print(f"Error: PDF file not found at {self.pdf_path}")
            return None
        except Exception as e:
            print(f"Error reading PDF: {e}")
            return None

    def write_output(self, content: str) -> bool:
        """Write content to output file."""
        try:
            os.makedirs(self.base_folder, exist_ok=True)
            with open(self.output_path, 'w', encoding='utf-8') as output_file:
                output_file.write(content)
            return True
        except Exception as e:
            print(f"Error writing output file: {e}")
            return False

    def extract_chapter_questions(self, chapter_name: str) -> list:
        """Extract all questions for a specific chapter."""
        try:
            with open(self.pdf_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                questions = []

                for page in pdf_reader.pages:
                    content = page.extract_text()
                    if chapter_name.lower() in content.lower():
                        # Basic question extraction (can be refined)
                        page_questions = [q.strip() for q in content.split('?') if '?' in q]
                        questions.extend(page_questions)

                if not questions:
                    print(f"No questions found for chapter: {chapter_name}")

                return questions

        except FileNotFoundError:
            print(f"Error: PDF file not found at {self.pdf_path}")
            return []
        except Exception as e:
            print(f"Error extracting chapter questions: {e}")
            return []

def main():
    if len(sys.argv) < 4:
        print("Usage: python pdf_processor.py <page_number> <chapter_name> <config_path>")
        quit()

    #page_number = sys.argv[0]
    page_number = 2
    chapter_name = sys.argv[0]
    config_path = sys.argv[1]

    processor = PDFProcessor(config_path)

    if not processor.validate_inputs(page_number, chapter_name):
        quit()

    # Read and write page content
    page_content = processor.read_pdf_page(int(page_number))
    if page_content:
        if processor.write_output(page_content):
            print(f"Page {page_number} content written to {processor.output_path}")

    # Extract and print chapter questions
    chapter_questions = processor.extract_chapter_questions(chapter_name)
    if chapter_questions:
        print(f"\nQuestions for Chapter {chapter_name}:")
        for idx, question in enumerate(chapter_questions, 1):
            print(f"{idx}. {question}")

if __name__ == "__main__":
    main()

# Commented out IPython magic to ensure Python compatibility.
# %%python pdf_processor.py 2 "Organic Chemistry" config.json

# Commented out IPython magic to ensure Python compatibility.
!pip install colab-xterm
# %load_ext colabxterm

# Commented out IPython magic to ensure Python compatibility.
# %xterm